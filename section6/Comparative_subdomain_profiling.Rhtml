<html>

<head>
<title>Avijit Podder Date: Nov14, 2024</title>

<head color="blue">

<h1><font color="blue">Individual subdomain Specific Z score Calculation using TMT Proteomics from the ROSMAP Cohort (comparative subdomain Profiling - AD-male vs AD-female)</font></h1>

</head>

<body>

<p>Percentage of individuals in each group with associated subdomains (subdomain)</p>

#<!--begin.rcode fig.width=20, fig.height=25
library(gplots)
library("ggplot2")
library(reshape2)
library(RColorBrewer)
library(dplyr)
library(viridis)
library(ggrepel)
library(corrplot)
library(plotly)


# Open subdomains comparison file"
data_subdomain <- read.csv("comarative_subdomain_results.csv", sep =",", header = TRUE, stringsAsFactors = FALSE)

# Open subdomains comparison file for Transcriptomic vs Proteomic
# Combine male and female together to get AD specific percentile in each group
#data_subdomain <- read.csv("AD_TvsP.csv", sep =",", header = TRUE, stringsAsFactors = FALSE)


head(data_subdomain)

# Distribution of Gene_ratio over the subdomains
#ggplot(data_subdomain, aes(x = Overlapping_gene_ratio)) +  
  #geom_histogram(binwidth = 0.05, fill = "blue", color = "black", alpha = 0.7) + 
  #geom_text(stat='bin', binwidth=0.05, aes(label=..count..), vjust=-0.5) + 
  #labs(title = "Histogram of Overlapping Gene Ratio", x = "Gene Ratio", y = "Frequency") + 
  #theme_minimal() +  
 # theme(text = element_text(size = 16))




# Removing the 1st and 2nd columns
data_subdomain_new <- data_subdomain[, -c(1, 2, 3, 4, 6)]

data_subdomain_new <- data_subdomain

head(data_subdomain_new)

data_matrix_subdomain <- data_subdomain_new[, -1]

# Replace NA values with 0 (or any other specific value)
data_matrix_subdomain[is.na(data_matrix_subdomain)] <- 0

# Set up the color scale using RColorBrewer
color_scale <- colorRampPalette(brewer.pal(9, "RdYlGn"))
color_scale1 <- colorRampPalette(c("white", "lightblue", "blue", "darkblue"))
color_scale2 <- colorRampPalette(brewer.pal(9, "RdGy"))
color_scale3 <- colorRampPalette(brewer.pal(9, "Greens"))
color_scale4 <- colorRampPalette(brewer.pal(9, "Blues"))
color_scale5 <- colorRampPalette(brewer.pal(9, "Purples"))
color_scale6 <- colorRampPalette(brewer.pal(9, "Oranges"))

# Reorder the columns
#data_matrix_subdomain <- data_matrix_subdomain[, c(
  #"UP_AD_T",
  #"UP_AD_P",
  #"DOWN_AD_T",
  #"DOWN_AD_P"
#)]

# Assign custom column names
#colnames(data_matrix_subdomain) <- c("UP_Trans", "UP_Prot", "DOWN_Trans", "DOWN_Prot")



heatmap.2(
as.matrix(data_matrix_subdomain),
Rowv = TRUE,
Colv = FALSE,
col = color_scale5,
scale = "none",  # Scale rows (genes) to Z-scores
trace = "none",  # Turn off row and column annotations
margins = c(15, 40),  # Set margins for row and column labels
key = TRUE,  # Include a color key
keysize = .5,  # Size of the color key
cexCol = 1,  # Set column label size
cexRow = 1,  # Set row label size
cellnote=round(data_matrix_subdomain, 2),
notecol="black",
labRow = data_subdomain$Biodomain_Subdomain,  # Row labels (subdomain name)
dendrogram = "row",  # Show both row and column dendrograms
main="Individuals (ratio) in each group exhibit a significant subdomain (subdomain)"
)

# subset the data where the value is equal to or greater than 0.05 in any row 
#subset_data_subdomain <- data_subdomain_new %>% filter(UP_AD_T >= 0.10 | UP_AD_P >= 0.10 | DOWN_AD_T >= 0.10 | DOWN_AD_P >= 0.10)


rownames(subset_data_subdomain) <- subset_data_subdomain$Biodomain_Subdomain

subset_data_subdomain <- subset_data_subdomain[, -1]

# Replace NA values with 0 (or any other specific value)
subset_data_subdomain[is.na(subset_data_subdomain)] <- 0

# Reorder the columns
#subset_data_subdomain <- subset_data_subdomain[, c(
  #"UP_AD_T",
  #"UP_AD_P",
  #"DOWN_AD_T",
  #"DOWN_AD_P"
)]

# Assign custom column names
#colnames(subset_data_subdomain) <- c("UP_Trans", "UP_Prot", "DOWN_Trans", "DOWN_Prot")


head(subset_data_subdomain, 3)


# Create the heatmap with filtered row names
heatmap.2(
     as.matrix(subset_data_subdomain),
     Rowv = TRUE,
     Colv = FALSE,
     col = color_scale5,
     scale = "none",
     trace = "none",
     margins = c(20, 40),
     key = TRUE,
     keysize = 1,
     cexCol = 2,
     cexRow = 1.5,
    cellnote=round(subset_data_subdomain, 2),
    notecol="black",
    dendrogram = "row",
    main = "subdomains Present in atleast 5% Individuals",
    srtCol = 45  # Rotate column headings by 45 degrees
)
########################################################################################################################################################################################################



# Calculate the correlation matrix
correlation_matrix <- cor(data_matrix_subdomain, use = "complete.obs")

# Plot only the upper half of the correlation matrix
corrplot(correlation_matrix, method = "circle", type = "upper", 
         tl.col = "black", tl.cex = 2, number.cex = 1.5, 
         addCoef.col = "black", diag = TRUE)

end.rcode-->

########################################################################################################################################################################################################
########################################################################################################################################################################################################

# UP and DOWN subdomain Separate ploting 

<!--begin.rcode fig.width=20, fig.height=25
library(gplots)
library("ggplot2")
library(reshape2)
library(RColorBrewer)
library(dplyr)
library(viridis)
library(ggrepel)
library(corrplot)
library(plotly)
library(patchwork)
library(stringr)


# Open subdomains comparison file"
#data_subdomain <- read.csv("comarative_subdomain_results.csv", sep =",", header = TRUE, stringsAsFactors = FALSE)

data_subdomain <- read.csv("comarative_subdomain_results_050525.csv", sep =",", header = TRUE, stringsAsFactors = FALSE)


# Truncate long Biodomain_Subdomain names to 40 characters
data_subdomain <- data_subdomain %>%
  mutate(Biodomain_Subdomain = str_trunc(Biodomain_Subdomain, width = 40))


# Removing the 1st and 2nd columns
data_subdomain_new_UP <- data_subdomain[, -c(1, 2, 3, 4, 7, 9, 11, 13)]

head(data_subdomain_new_UP)

data_subdomain_new_DOWN <- data_subdomain[, -c(1, 2, 3, 4, 6, 8, 10, 12)]

head(data_subdomain_new_DOWN)


data_matrix_subdomain_UP <- data_subdomain_new_UP[, -1]

# Reorder the columns
data_matrix_subdomain_UP <- data_matrix_subdomain_UP[, c(
  "UP_ratio_AD_female",
  "UP_ratio_AsymAD_female",
  "UP_ratio_AD_male",
  "UP_ratio_AsymAD_male"
)]


data_matrix_subdomain_DOWN <- data_subdomain_new_DOWN[, -1]

# Reorder the columns
data_matrix_subdomain_DOWN <- data_matrix_subdomain_DOWN[, c(
  "DOWN_ratio_AD_female",
  "DOWN_ratio_AsymAD_female",
  "DOWN_ratio_AD_male",
  "DOWN_ratio_AsymAD_male"
)]



# Replace NA values with 0 (or any other specific value)
data_matrix_subdomain_UP[is.na(data_matrix_subdomain_UP)] <- 0
data_matrix_subdomain_DOWN[is.na(data_matrix_subdomain_DOWN)] <- 0

# Set up the color scale using RColorBrewer
color_scale <- colorRampPalette(brewer.pal(9, "RdYlGn"))

# Assign custom column names
colnames(data_matrix_subdomain_UP) <- c("AD_Female", "AsymAD_Female", "AD_Male", "AsymAD_Male")

# Assign custom column names
colnames(data_matrix_subdomain_DOWN) <- c("AD_Female", "AsymAD_Female", "AD_Male", "AsymAD_Male")


# Set up the color scale using RColorBrewer
color_scale <- colorRampPalette(brewer.pal(9, "RdYlGn"))
color_scale1 <- colorRampPalette(c("white", "lightblue", "blue", "darkblue"))
color_scale2 <- colorRampPalette(brewer.pal(9, "RdGy"))
color_scale3 <- colorRampPalette(brewer.pal(9, "Greens"))
color_scale4 <- colorRampPalette(brewer.pal(9, "Blues"))
color_scale5 <- colorRampPalette(brewer.pal(9, "Purples"))
color_scale6 <- colorRampPalette(brewer.pal(9, "Oranges"))



heatmap.2(
as.matrix(data_matrix_subdomain_UP),
Rowv = TRUE,
Colv = FALSE,
col = color_scale3,
scale = "none",  # Scale rows (genes) to Z-scores
trace = "none",  # Turn off row and column annotations
margins = c(20, 40),  # Set margins for row and column labels
key = TRUE,  # Include a color key
keysize = .5,  # Size of the color key
cexCol = 1.5,  # Set column label size
cexRow = 1,  # Set row label size
cellnote=round(data_matrix_subdomain_UP, 2),
notecol="black",
labRow = data_subdomain$Biodomain_Subdomain,  # Row labels (subdomain name)
dendrogram = "row",  # Show both row and column dendrograms
main="Individuals (ratio) in each group exhibit a significant subdomain (subdomain)"
)


heatmap.2(
as.matrix(data_matrix_subdomain_DOWN),
Rowv = TRUE,
Colv = FALSE,
col = color_scale6,
scale = "none",  # Scale rows (genes) to Z-scores
trace = "none",  # Turn off row and column annotations
margins = c(20, 40),  # Set margins for row and column labels
key = TRUE,  # Include a color key
keysize = .5,  # Size of the color key
cexCol = 1.5,  # Set column label size
cexRow = 1,  # Set row label size
cellnote=round(data_matrix_subdomain_DOWN, 2),
notecol="black",
labRow = data_subdomain$Biodomain_Subdomain,  # Row labels (subdomain name)
dendrogram = "row",  # Show both row and column dendrograms
main="Individuals (ratio) in each group exhibit a significant subdomain (subdomain)"
)

########################################################################################################################################################################################################

subset_data_subdomain_UP <- data_subdomain_new_UP %>% filter(UP_ratio_AD_female >= 0.10 | UP_ratio_AD_male >= 0.10 | UP_ratio_AsymAD_female >= 0.10 | UP_ratio_AsymAD_male >= 0.10)

subset_data_subdomain_DOWN <- data_subdomain_new_DOWN %>% filter(DOWN_ratio_AD_female >= 0.10 | DOWN_ratio_AD_male >= 0.10 | DOWN_ratio_AsymAD_female >= 0.10 | DOWN_ratio_AsymAD_male >= 0.10)


rownames(subset_data_subdomain_UP) <- subset_data_subdomain_UP$Biodomain_Subdomain
rownames(subset_data_subdomain_DOWN) <- subset_data_subdomain_DOWN$Biodomain_Subdomain


subset_data_subdomain_UP <- subset_data_subdomain_UP[, -1]
subset_data_subdomain_DOWN <- subset_data_subdomain_DOWN[, -1]


# Replace NA values with 0 (or any other specific value)
subset_data_subdomain_UP[is.na(subset_data_subdomain_UP)] <- 0
subset_data_subdomain_DOWN[is.na(subset_data_subdomain_DOWN)] <- 0


head(subset_data_subdomain_UP, 3)

head(subset_data_subdomain_DOWN, 3)




# Reorder the columns
subset_data_subdomain_UP <- subset_data_subdomain_UP[, c(
  "UP_ratio_AD_female",
  "UP_ratio_AsymAD_female",
  "UP_ratio_AD_male",
  "UP_ratio_AsymAD_male"
)]

subset_data_subdomain_DOWN <- subset_data_subdomain_DOWN[, c(
  "DOWN_ratio_AD_female",
  "DOWN_ratio_AsymAD_female",
  "DOWN_ratio_AD_male",
  "DOWN_ratio_AsymAD_male"
)]


# Assign custom column names
colnames(subset_data_subdomain_UP) <- c("AD_Female", "AsymAD_Female", "AD_Male", "AsymAD_Male")

colnames(subset_data_subdomain_DOWN) <- c("AD_Female", "AsymAD_Female", "AD_Male", "AsymAD_Male")




# Create the heatmap with filtered row names
UP <- heatmap.2(
     as.matrix(subset_data_subdomain_UP),
     Rowv = TRUE,
     Colv = FALSE,
     col = color_scale3,
     scale = "none",
     trace = "none",
     margins = c(20, 50),
     key = TRUE,
     keysize = .50,
     cexCol = 2.5,
     srtCol = 45,
     cexRow = 2.5,
    cellnote=round(subset_data_subdomain_UP, 2),
    notecex=2,
    notecol="black",
    dendrogram = "row",
    main = "subdomains Present in atleast 5% Individuals"
)

# Create the heatmap with filtered row names
DOWN <- heatmap.2(
     as.matrix(subset_data_subdomain_DOWN),
     Rowv = TRUE,
     Colv = FALSE,
     col = color_scale6,
     scale = "none",
     trace = "none",
     margins = c(20, 50),
     key = TRUE,
     keysize = .50,
     cexCol = 2.5,
     srtCol = 45,
     cexRow = 2.5,
    cellnote=round(subset_data_subdomain_DOWN, 2),
    notecex=2,
    notecol="black",
    dendrogram = "row",
    main = "subdomains Present in atleast 5% Individuals"
)

end.rcode-->

<p>Comparative analysis between/within group for associated subdomains (subdomain)</p>

#<!--begin.rcode fig.width=25, fig.height=15

########################################################################################################################################################################################################

# Define a custom color palette with distinct colors for each biodomain (different type of Biodomain - color define by Greg Carry)
custom_colors <- c("Apoptosis" = "#673399", "APP Metabolism" = "#fe6500", "Autophagy" = "#9931fd", "Cell Cycle" = "#18857f", "DNA Repair" = "#f451ad", "Endolysosome" = "#3466cc", "Epigenetic" = "#cb3233", "Immune Response" = "#9ccdcc", "Lipid Metabolism" = "#989898", "Metal Binding and Homeostasis" = "#4b0d20", "Mitochondrial Metabolism" = "#97cb98", "Myelination" = "#996735", "Oxidative Stress" = "#ffcd66", "Proteostasis" = "#c8b269", "RNA Spliceosome" = "#0c9aff", "Structural Stabilization" = "#ff9a9a", "Synapse" = "#329a33", "Tau Homeostasis" = "#cb97cb", "Vasculature" = "#cecd02", "none" = "#7f7f7f")

## AD

# Total number of individual for subdomain enrichment in AD (Male vs Female)
#ggplot(data_subdomain, aes(x= Total_count_AD_female, y= Total_count_AD_male, color = subdomain_gene_ratio)) +geom_point(alpha=0.3, shape=21, color="black") + theme_bw() + geom_text_repel(aes(label = unique_id), size = 7.5) + geom_smooth(method = 'lm', colour="red", size=0.5) +  scale_color_gradient(low="red", high="black") + theme(text = element_text(size=20))

# Sex specific UP subdomain enrichment in AD (Male vs Female)
ggplot(data_subdomain, aes(x= UP_ratio_AD_female, y= UP_ratio_AD_male, color = Biodomain, size = Overlapping_gene_ratio)) + geom_point(aes(color=Biodomain), alpha=.3, stroke = 0)  + theme_bw() + geom_text_repel(aes(label = unique_id), size = 7) + geom_smooth(method = 'lm', colour="red", size=0.5) + theme(text = element_text(size=20)) + scale_color_manual(values = custom_colors) + labs(color = "Biodomain")

# Sex specific DOWN subdomain enrichment in AD (Male vs Female)
ggplot(data_subdomain, aes(x= DOWN_ratio_AD_female, y= DOWN_ratio_AD_male, color = Biodomain, size = Overlapping_gene_ratio)) + geom_point(aes(color=Biodomain), alpha=.3, stroke = 0)  + theme_bw() + geom_text_repel(aes(label = unique_id), size = 7) + geom_smooth(method = 'lm', colour="red", size=0.5) + theme(text = element_text(size=20)) + scale_color_manual(values = custom_colors)  + labs(color = "Biodomain")


# UP and DOWN subdomains comparison in AD (Female)
ggplot(data_subdomain, aes(x= DOWN_ratio_AD_female, y= UP_ratio_AD_female, color = Biodomain, size = Overlapping_gene_ratio)) + geom_point(aes(color=Biodomain), alpha=.3, stroke = 0)  + theme_bw() + geom_text_repel(aes(label = unique_id), size = 7) + geom_smooth(method = 'lm', colour="red", size=0.5) + theme(text = element_text(size=20)) + scale_color_manual(values = custom_colors)  + labs(color = "Biodomain")

# UP and DOWN subdomains comparison in AD (Male)
ggplot(data_subdomain, aes(x= DOWN_ratio_AD_male, y= UP_ratio_AD_male, color = Biodomain, size = Overlapping_gene_ratio)) + geom_point(aes(color=Biodomain), alpha=.3, stroke = 0)  + theme_bw() + geom_text_repel(aes(label = unique_id), size = 7) + geom_smooth(method = 'lm', colour="red", size=0.5) + theme(text = element_text(size=20)) + scale_color_manual(values = custom_colors)  + labs(color = "Biodomain")

########################################################################################################################################################################################################
## AsymAD

# Sex specific UP subdomain enrichment in AsymAD (Male vs Female)
ggplot(data_subdomain, aes(x= UP_ratio_AsymAD_female, y= UP_ratio_AsymAD_male, color = Biodomain, size = Overlapping_gene_ratio)) + geom_point(aes(color=Biodomain), alpha=.3, stroke = 0)  + theme_bw() + geom_text_repel(aes(label = unique_id), size = 7) + geom_smooth(method = 'lm', colour="red", size=0.5) + theme(text = element_text(size=20)) + scale_color_manual(values = custom_colors)  + labs(color = "Biodomain")

# Sex specific DOWN subdomain enrichment in AsymAD (Male vs Female)
ggplot(data_subdomain, aes(x= DOWN_ratio_AsymAD_female, y= DOWN_ratio_AsymAD_male, color = Biodomain, size = Overlapping_gene_ratio)) + geom_point(aes(color=Biodomain), alpha=.3, stroke = 0)  + theme_bw() + geom_text_repel(aes(label = unique_id), size = 7) + geom_smooth(method = 'lm', colour="red", size=0.5) + theme(text = element_text(size=20)) + scale_color_manual(values = custom_colors)  + labs(color = "Biodomain")


# UP and DOWN subdomains comparison in AsymAD (Female)
ggplot(data_subdomain, aes(x= DOWN_ratio_AsymAD_female, y= UP_ratio_AsymAD_female, color = Biodomain, size = Overlapping_gene_ratio)) + geom_point(aes(color=Biodomain), alpha=.3, stroke = 0)  + theme_bw() + geom_text_repel(aes(label = unique_id), size = 7) + geom_smooth(method = 'lm', colour="red", size=0.5) + theme(text = element_text(size=20)) + scale_color_manual(values = custom_colors)  + labs(color = "Biodomain")

# UP and DOWN subdomains comparison in AsymAD (Male)
ggplot(data_subdomain, aes(x= DOWN_ratio_AsymAD_male, y= UP_ratio_AsymAD_male, color = Biodomain, size = Overlapping_gene_ratio)) + geom_point(aes(color=Biodomain), alpha=.3, stroke = 0)  + theme_bw() + geom_text_repel(aes(label = unique_id), size = 7) + geom_smooth(method = 'lm', colour="red", size=0.5) + theme(text = element_text(size=20)) + scale_color_manual(values = custom_colors)  + labs(color = "Biodomain")

########################################################################################################################################################################################################
## AD vs AsymAD

# UP subdomain enrichment in AsymAD vs AD (Female)
ggplot(data_subdomain, aes(x= UP_ratio_AsymAD_female, y= UP_ratio_AD_female, color = Biodomain, size = Overlapping_gene_ratio)) + geom_point(aes(color=Biodomain), alpha=.3, stroke = 0)  + theme_bw() + geom_text_repel(aes(label = unique_id), size = 7) + geom_smooth(method = 'lm', colour="red", size=0.5) + theme(text = element_text(size=20)) + scale_color_manual(values = custom_colors)  + labs(color = "Biodomain")


# DOWN subdomain enrichment in AsymAD vs AD (Female)
ggplot(data_subdomain, aes(x= DOWN_ratio_AsymAD_female, y= DOWN_ratio_AD_female, color = Biodomain, size = Overlapping_gene_ratio)) + geom_point(aes(color=Biodomain), alpha=.3, stroke = 0)  + theme_bw() + geom_text_repel(aes(label = unique_id), size = 7) + geom_smooth(method = 'lm', colour="red", size=0.5) + theme(text = element_text(size=20)) + scale_color_manual(values = custom_colors)  + labs(color = "Biodomain")


# UP subdomain enrichment in AsymAD vs AD (Male)
ggplot(data_subdomain, aes(x= UP_ratio_AsymAD_male, y= UP_ratio_AD_male, color = Biodomain, size = Overlapping_gene_ratio)) + geom_point(aes(color=Biodomain), alpha=.3, stroke = 0)  + theme_bw() + geom_text_repel(aes(label = unique_id), size = 7) + geom_smooth(method = 'lm', colour="red", size=0.5) + theme(text = element_text(size=20)) + scale_color_manual(values = custom_colors)  + labs(color = "Biodomain")


# DOWN subdomain enrichment in AsymAD vs AD (Male)
ggplot(data_subdomain, aes(x= DOWN_ratio_AsymAD_male, y= DOWN_ratio_AD_male, color = Biodomain, size = Overlapping_gene_ratio)) + geom_point(aes(color=Biodomain), alpha=.3, stroke = 0)  + theme_bw() + geom_text_repel(aes(label = unique_id), size = 7) + geom_smooth(method = 'lm', colour="red", size=0.5) + theme(text = element_text(size=20)) + scale_color_manual(values = custom_colors)  + labs(color = "Biodomain")


########################################################################################################################################################################################################

# Convert to interactive plot using plotly

data_subdomain_long <- melt(data_subdomain_new, id.vars = "Biodomain_Subdomain")

p <- ggplot(data_subdomain_long, aes(x = Biodomain_Subdomain, y = value, color = variable, group = variable)) +
     geom_line(size = 1.2) +              # Line plot
     geom_point(size = 3) +               # Add points to the line
     labs(title = "Comparative Plot for AD and AsymAD Ratios",
          x = "Biodomain_Subdomain Name", 
          y = "Ratio Value") +
     theme_minimal() +
     theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5),  # Rotate x-axis labels for better readability
           text = element_text(size = 14))

interactive_plot <- ggplotly(p)

interactive_plot

# Save the interactive plot as an HTML file
htmlwidgets::saveWidget(interactive_plot, "Subdomain_interactive_plot.html")

########################################################################################################################################################################################################

end.rcode-->

<p>Comparative analysis between/within group for associated subdomains (subdomain)</p>

<!--begin.rcode fig.width=25, fig.height=15

########################################################################################################################################################################################################
# Male vs Female

# Define a custom color palette with distinct colors for each biodomain (different type of Biodomain - color define by Greg Carry)
custom_colors <- c("Apoptosis" = "#673399", "APP Metabolism" = "#fe6500", "Autophagy" = "#9931fd", "Cell Cycle" = "#18857f", "DNA Repair" = "#f451ad", "Endolysosome" = "#3466cc", "Epigenetic" = "#cb3233", "Immune Response" = "#9ccdcc", "Lipid Metabolism" = "#989898", "Metal Binding and Homeostasis" = "#4b0d20", "Mitochondrial Metabolism" = "#97cb98", "Myelination" = "#996735", "Oxidative Stress" = "#ffcd66", "Proteostasis" = "#c8b269", "RNA Spliceosome" = "#0c9aff", "Structural Stabilization" = "#ff9a9a", "Synapse" = "#329a33", "Tau Homeostasis" = "#cb97cb", "Vasculature" = "#cecd02", "none" = "#7f7f7f")

#  Male vs Female AD
# Open the subdomain file where UP (+) and DOWN (-) subdomains are merged together in a single column and the data is separated as a comparison for Male vs Female subdomains
#data_subdomain_MvF_AD <- read.csv("Male_Female_comarative_subdomain_results.csv", sep =",", header = TRUE, stringsAsFactors = FALSE)

data_subdomain_MvF_AD <- read.csv("Male_Female_comarative_subdomain_results_050525.csv", sep =",", header = TRUE, stringsAsFactors = FALSE)


head(data_subdomain_MvF_AD, 5)

# Plot the data as a comparison for Male vs Female subdomains
ggplot(data_subdomain_MvF_AD, aes(x = Female, y = Male, color = Biodomain, size = Difference)) +
geom_point(aes(color=Biodomain, size = Difference), alpha=0.6, stroke = 0) + 
 theme_bw() +
    # Conditionally label points where AD or AsymAD values are greater than 0.05
    geom_text_repel(
        aes(label = ifelse((Male > 0.10 & Female < 0.05) | (Female > 0.07 & Male < 0.05) | (Female > 0.07 & Male > 0.07), Biodomain_Subdomain, "")),
       size = 6, max.overlaps = Inf
    ) +
  
    scale_color_manual(values = custom_colors) +
    labs(color = "AD Biodomain") +
    # Add x = y line
    geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray", size = 0.5) +
    # Add horizontal and vertical dashed lines
    geom_hline(yintercept = 0.05, linetype = "dashed", color = "gray") +
    geom_hline(yintercept = 0.10, linetype = "dashed", color = "red") +
    geom_vline(xintercept = 0.05, linetype = "dashed", color = "gray") +
    geom_vline(xintercept = 0.10, linetype = "dashed", color = "red") +
    labs(title = "Subdomain Comparisons for Female_AD vs Male_AD", x = "Female (% of subjects)", y = "Male (% of subjects)") +
    theme(
    text = element_text(size = 30),
    legend.position = "right",
    axis.text = element_text(size = 30),
    axis.title = element_text(size = 30)
  )

########################################################################################################################################################################################################

# Wrap long Subdomain names
#data_subdomain_MvF_AD <- data_subdomain_MvF_AD %>%
    #mutate(Subdomain_wrapped = str_wrap(Subdomain, width = 25))

ggplot(data_subdomain_MvF_AD, aes(x = Male, y = Female, color = Biodomain, size = Difference)) +
    geom_point(alpha = 0.6, stroke = 0) +  # Increased alpha for better visibility
    theme_bw() +

    # Conditionally label points where |Male - Female| >= 0.05
    geom_text_repel(
        aes(label = ifelse((abs(Female - Male) >= 0.07) | (Female > 0.07 & Male > 0.07), Subdomain, "")),
        size = 8,
        max.overlaps = Inf  # Ensure all significant labels are shown
    ) +
  
   scale_size(range = c(.1, 10), name="% Difference") +

    scale_color_manual(values = custom_colors) +

    labs(color = "AD Biodomain") +

    # Add x = y reference line
    geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray", linewidth = 0.5) +

    # Add horizontal and vertical threshold lines
    geom_hline(yintercept = 0.05, linetype = "dashed", color = "gray") +
    geom_hline(yintercept = 0.10, linetype = "dashed", color = "red") +
    geom_vline(xintercept = 0.05, linetype = "dashed", color = "gray") +
    geom_vline(xintercept = 0.10, linetype = "dashed", color = "red") +

    labs(title = "Subdomain Comparisons for Female_AD vs Male_AD", 
         x = "Male (% of subjects)", 
         y = "Female (% of subjects)") +

    theme(
        text = element_text(size = 30),
        legend.position = "right",
        axis.text = element_text(size = 30),
        axis.title = element_text(size = 30)
    ) +
  theme(legend.text=element_text(size=16))
########################################################################################################################################################################################################

# Calculate difference dynamically (Female - Male)
data_subdomain_MvF_AD <- data_subdomain_MvF_AD %>%
    mutate(Difference = Female - Male) %>%  # Compute difference
    arrange(Difference)  # Sort data: Male-dominant (negative) first, Female-dominant (positive) last

# Select top pathways for better visualization
top_n <- 20  # Adjust this number as needed
data_top <- data_subdomain_MvF_AD[c(1:(top_n/2), (nrow(data_subdomain_MvF_AD) - (top_n/2) + 1):nrow(data_subdomain_MvF_AD)), ]

# Create a diverging bar plot with value labels
ggplot(data_top, aes(x = reorder(Biodomain_Subdomain, Difference), y = Difference, fill = Difference > 0)) +
    geom_bar(stat = "identity", show.legend = FALSE) +
    
    coord_flip() +  # Flip for horizontal bars
    scale_fill_manual(values = c("blue", "red")) +  # Blue = Male-dominant, Red = Female-dominant
    theme_minimal() +
    labs(title = "Top Male vs Female Subdomains",
         #subtitle = "Red = More Female-Dominant | Blue = More Male-Dominant",
         x = "Biodomain_Subdomain",
         y = "% Difference") +
    theme(text = element_text(size = 14),
          axis.text = element_text(size = 14))


ggplot(data_top, aes(x = reorder(Biodomain_Subdomain, Difference), y = Difference, fill = Direction)) +
    geom_bar(stat = "identity", show.legend = TRUE) +
    geom_text(aes(label = paste0(round(abs(Difference) * 100, 1), "%")),  # absolute value ×100 + % sign
              hjust = ifelse(data_top$Difference >= 0, -0.1, 1.1),        # position text left or right
              size = 8) +
    coord_flip() +  # horizontal bars
    scale_fill_manual(values = c("DOWN" = "lightcoral", "UP" = "palegreen")) +
    theme_minimal() +
    labs(title = "Top Male vs Female Subdomains",
         x = "Biodomain_Subdomain",
         y = "% Difference",
         fill = "Direction") +
    theme(text = element_text(size = 30),
          axis.text = element_text(size = 20)) +
    expand_limits(y = c(min(data_top$Difference) * 1.2, max(data_top$Difference) * 1.2))

#######################################################################################################################################################################################################
library(ggplot2)
library(dplyr)
library(tidyr)

# Select top N subdomains by absolute difference
top_n <- 20
data_top <- data_subdomain_MvF_AD %>%
    mutate(Difference = Female - Male,
           AbsDifference = abs(Difference)) %>%
    arrange(desc(AbsDifference)) %>%
    slice(1:top_n)

# Reshape to long format (Female and Male side-by-side)
data_long <- data_top %>%
    select(Biodomain_Subdomain_initial, Direction, Female, Male) %>%
    pivot_longer(cols = c(Female, Male), names_to = "Group", values_to = "Value") %>%
    mutate(
        Percent = Value * 100,
        # Invert values for DOWN direction to go on the left
        PlotValue = ifelse(Direction == "DOWN", -Percent, Percent),
        Group = factor(Group, levels = c("Female", "Male"))
    )

# Plot
ggplot(data_long, aes(x = reorder(Biodomain_Subdomain_initial, PlotValue), y = PlotValue)) +
    geom_segment(aes(xend = Biodomain_Subdomain_initial, y = 0, yend = PlotValue, color = Group),
                 size = 1.5) +
    geom_point(aes(color = Group), size = 5) +
    geom_text(aes(label = paste0(round(abs(PlotValue), 1), "%"), color = Group),
              hjust = ifelse(data_long$PlotValue > 0, -0.2, 1.2),
              nudge_x = 0.4,
              size = 5) +
    coord_flip() +
    scale_color_manual(values = c("Female" = "hotpink4", "Male" = "lightblue4")) +
    labs(
        title = "Top 10 Diverging Subdomains: Female vs Male",
        x = "Biodomain (Subdomain)",
        y = "Percentage (Direction-Based)",
        color = "Group"
    ) +
    theme_minimal(base_size = 15) +
    theme(
        text = element_text(size = 18),
        axis.text.y = element_text(size = 14),
        legend.position = "top"
    ) +
    expand_limits(y = c(-max(data_long$Percent) * 1.2, max(data_long$Percent) * 1.2))

########################################################################################################################################################################################################
########################################################################################################################################################################################################
#  AD vs AsymAD 
# Open the subdomains where the Male and Female percentages are combined together to get AD and AsymAD specific subdomains
# Further, UP (+) and DOWN (-) subdomains are merged together in a single column and the data is separated as a comparison for AD vs AsymAD subdomains

#data_subdomain_ADvAsymAD <- read.csv("AD_AsymAD_comarative_subdomain_results.csv", sep =",", header = TRUE, stringsAsFactors = FALSE)

data_subdomain_ADvAsymAD <- read.csv("AD_AsymAD_comarative_subdomain_results_050525.csv", sep =",", header = TRUE, stringsAsFactors = FALSE)


head(data_subdomain_ADvAsymAD, 5)

# Plot the data as a comparison for AD vs AsymAD pathways

ggplot(data_subdomain_ADvAsymAD, aes(x = AD, y = AsymAD, color = Biodomain, size = Difference)) +
    geom_point(aes(color = Biodomain, size = Difference), alpha = 0.3, stroke = 0) + 
    theme_bw() +
    # Conditionally label points based on the specified conditions
    geom_text_repel(
        aes(label = ifelse((AD > 0.10 & Difference > 0.05) | (AsymAD > 0.10 & Difference > 0.05) | (AD > 0.15 & AsymAD > 0.15), Subdomain, "")),
        size = 8
    ) +
    scale_color_manual(values = custom_colors) +
    labs(color = "AD Biodomain") +
    # Add x = y line
    geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray", size = 0.5) +
    # Add horizontal and vertical dashed lines
    geom_hline(yintercept = 0.05, linetype = "dashed", color = "gray") +
    geom_hline(yintercept = 0.10, linetype = "dashed", color = "red") +
    geom_vline(xintercept = 0.05, linetype = "dashed", color = "gray") +
    geom_vline(xintercept = 0.10, linetype = "dashed", color = "red") +
    labs(title = "Subdomain Comparisons for AD vs AsymAD", x = "AD (% of subjects)", y = "AsymAD (% of subjects)") +
    theme(
    text = element_text(size = 30),
    legend.position = "right",
    axis.text = element_text(size = 30),
    axis.title = element_text(size = 30)
  )

########################################################################################################################################################################################################


# Wrap long Subdomain names
#data_subdomain_ADvAsymAD <- data_subdomain_ADvAsymAD %>%
    #mutate(Subdomain_wrapped = str_wrap(Subdomain, width = 25))


ggplot(data_subdomain_ADvAsymAD, aes(x = AD, y = AsymAD, color = Biodomain, size = Difference)) +
    geom_point(alpha = 0.3, stroke = 0) +  # Points with transparency
    theme_bw() +
    
    # Conditionally label points where |AD - AsymAD| >= 0.05
    geom_text_repel(
        aes(label = ifelse((abs(AD - AsymAD) >= 0.06) | (AD > 0.15 & AsymAD > 0.15), Subdomain, "")),
        size = 8, max.overlaps = Inf
    ) +
    
    scale_size(range = c(.1, 10), name="% Difference") +
  
    scale_color_manual(values = custom_colors) +
    labs(color = "AD Biodomain") +
    
    # Add x = y reference line
    geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray", size = 0.5) +
    
    # Add horizontal and vertical threshold lines
    geom_hline(yintercept = 0.05, linetype = "dashed", color = "gray") +
    geom_hline(yintercept = 0.10, linetype = "dashed", color = "red") +
    geom_vline(xintercept = 0.05, linetype = "dashed", color = "gray") +
    geom_vline(xintercept = 0.10, linetype = "dashed", color = "red") +
    
    # Title and axis labels
    labs(title = "Subdomain Comparisons for AD vs AsymAD", 
         x = "AD (% of subjects)", 
         y = "AsymAD (% of subjects)") +
    
    # Theme customization
    theme(
        text = element_text(size = 30),
        legend.position = "right",
        axis.text = element_text(size = 30),
        axis.title = element_text(size = 30)
    ) +
  theme(legend.text=element_text(size=16))

#######################################################################################################################################################################################################

# Calculate difference dynamically (AD - AsuymAD)
data_subdomain_ADvAsymAD <- data_subdomain_ADvAsymAD %>%
    mutate(Difference = AD - AsymAD) %>%  # Compute difference
    arrange(Difference)  # Sort data: AD-dominant (negative) first, AsymAD-dominant (positive) last

# Select top pathways for better visualization
top_n <- 20  # Adjust this number as needed
data_top <- data_subdomain_ADvAsymAD[c(1:(top_n/2), (nrow(data_subdomain_ADvAsymAD) - (top_n/2) + 1):nrow(data_subdomain_ADvAsymAD)), ]

# Create a diverging bar plot with value labels

ggplot(data_top, aes(x = reorder(Biodomain_Subdomain_initial, Difference), y = Difference, fill = Difference > 0)) +
    geom_bar(stat = "identity", show.legend = FALSE) +
    
    coord_flip() +  # Flip for horizontal bars
    scale_fill_manual(values = c("blue", "red")) +  # Blue = Male-dominant, Red = Female-dominant
    theme_minimal() +
    labs(title = "Top AD vs AsymAD Subdomains",
         x = "Biodomain_Subdomain",
         y = "% Difference") +
    theme(text = element_text(size = 14),
          axis.text = element_text(size = 14))




ggplot(data_top, aes(x = reorder(Biodomain_Subdomain, Difference), y = Difference, fill = Direction)) +
    geom_bar(stat = "identity", show.legend = TRUE) +
    geom_text(aes(label = paste0(round(abs(Difference) * 100, 1), "%")),  # absolute value ×100 + % sign
              hjust = ifelse(data_top$Difference >= 0, -0.1, 1.1),        # position text left or right
              size = 8) +
    coord_flip() +  # horizontal bars
    scale_fill_manual(values = c("DOWN" = "lightcoral", "UP" = "palegreen")) +
    theme_minimal() +
    labs(title = "Top AD vs AsymAD Subdomains",
         x = "Biodomain (Subdomain)",
         y = "% Difference",
         fill = "Direction") +
    theme(text = element_text(size = 30),
          axis.text = element_text(size = 20)) +
    expand_limits(y = c(min(data_top$Difference) * 1.2, max(data_top$Difference) * 1.2))

#######################################################################################################################################################################################################

library(ggplot2)
library(dplyr)
library(tidyr)

# Select top N subdomains by absolute difference
top_n <- 20
data_top <- data_subdomain_ADvAsymAD %>%
    mutate(Difference = AD - AsymAD,
           AbsDifference = abs(Difference)) %>%
    arrange(desc(AbsDifference)) %>%
    slice(1:top_n)

# Reshape to long format (AD and AsymAD side-by-side)
data_long <- data_top %>%
    select(Biodomain_Subdomain_initial, Direction, AD, AsymAD) %>%
    pivot_longer(cols = c(AD, AsymAD), names_to = "Group", values_to = "Value") %>%
    mutate(
        Percent = Value * 100,
        # Invert values for DOWN direction to go on the left
        PlotValue = ifelse(Direction == "DOWN", -Percent, Percent),
        Group = factor(Group, levels = c("AD", "AsymAD"))
    )

# Plot
ggplot(data_long, aes(x = reorder(Biodomain_Subdomain_initial, PlotValue), y = PlotValue)) +
    geom_segment(aes(xend = Biodomain_Subdomain_initial, y = 0, yend = PlotValue, color = Group),
                 size = 1.5) +
    geom_point(aes(color = Group), size = 5) +
    geom_text(aes(label = paste0(round(abs(PlotValue), 1), "%"), color = Group),
              hjust = ifelse(data_long$PlotValue > 0, -0.2, 1.2), 
              nudge_x = 0.4, 
              size = 5) +
    coord_flip() +
    scale_color_manual(values = c("AD" = "purple4", "AsymAD" = "mediumpurple1")) +
    labs(
        title = "Top 10 Diverging Subdomains: AD vs AsymAD",
        x = "Biodomain (Subdomain)",
        y = "Percentage (Direction-Based)",
        color = "Group"
    ) +
    theme_minimal(base_size = 15) +
    theme(
        text = element_text(size = 18),
        axis.text.y = element_text(size = 14),
        legend.position = "top"
    ) +
    expand_limits(y = c(-max(data_long$Percent) * 1.2, max(data_long$Percent) * 1.2))


end.rcode-->
########################################################################################################################################################################################################
########################################################################################################################################################################################################

#  Transcriptomics vs Proteomics
# Open the subdomains where the Male and Female percentages are combined together to get AD specific subdomains in transcriptomics and proteomics analysis
# Further, UP (+) and DOWN (-) subdomains are merged together in a single column and the data is separated as a comparison for AD vs AsymAD subdomains

data_subdomain_AD_TvsP <- read.csv("AD_trans_prot_comp.csv", sep =",", header = TRUE, stringsAsFactors = FALSE)

head(data_subdomain_AD_TvsP, 5)


ggplot(data_subdomain_AD_TvsP, aes(x = AD_Transcriptome, y = AD_proteome, color = Biodomain, size = Difference)) +
    geom_point(alpha = 0.3, stroke = 0) +  # Points with transparency
    theme_bw() +
    
    # Conditionally label points where |AD_Transcriptome - AD_proteome| >= 0.05
    geom_text_repel(
        aes(label = ifelse((abs(AD_Transcriptome - AD_proteome) >= 0.05) | (AD_Transcriptome > 0.10 & AD_proteome > 0.10), Biodomain_Subdomain, "")),
        size = 6
    ) +
    
    scale_color_manual(values = custom_colors) +
    labs(color = "Biodomain") +
    
    # Add x = y reference line
    geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray", size = 0.5) +
    
    # Add horizontal and vertical threshold lines
    geom_hline(yintercept = 0.05, linetype = "dashed", color = "gray") +
    geom_hline(yintercept = 0.10, linetype = "dashed", color = "red") +
    geom_vline(xintercept = 0.05, linetype = "dashed", color = "gray") +
    geom_vline(xintercept = 0.10, linetype = "dashed", color = "red") +
    
    # Title and axis labels
    labs(title = "Subdomain Comparisons for Transcriptomics vs Proteomics", 
         x = "AD_Transcriptome (% of subjects)", 
         y = "AD_proteome (% of subjects)") +
    
    # Theme customization
    theme(
        text = element_text(size = 30),
        legend.position = "right",
        axis.text = element_text(size = 30),
        axis.title = element_text(size = 30)
    )

########################################################################################################################################################################################################

#  Transcriptomics vs Proteomics
# All eight groups comparison together

library(ggplot2)
library(dplyr)
library(tidyr)
library(ggrepel)

Cases_TvsP <- read.csv("Cases_TvsP.csv", sep =",", header = TRUE, stringsAsFactors = FALSE)

head(Cases_TvsP, 5)


# Identify column pairs that have "_T" and "_P"
column_pairs <- unique(gsub("(_T|_P)$", "", names(Cases_TvsP)))

# Create a list to store transformed data
plot_data <- list()

# Debugging: Print identified column pairs
print(column_pairs)

# Loop through column pairs and extract matching "_T" and "_P" columns
for (col in column_pairs) {
    T_col <- paste0(col, "_T")
    P_col <- paste0(col, "_P")

    # Debugging: Check if columns exist
    if (T_col %in% names(Cases_TvsP) & P_col %in% names(Cases_TvsP)) {
        print(paste("Processing:", T_col, "vs", P_col))  # Debugging info

        # Identify AD vs AsymAD group
        group_type <- ifelse(grepl("AD_", col), "AD", "AsymAD")

        temp_df <- Cases_TvsP %>%
            select(unique_id, Biodomain, all_of(T_col), all_of(P_col)) %>%
            rename(X = all_of(T_col), Y = all_of(P_col)) %>%
            mutate(Difference = abs(X - Y),
                   Comparison = col,  # Store column name
                   Group = group_type)  # Mark whether it's AD or AsymAD

        plot_data[[col]] <- temp_df  # Store in list
    } else {
        print(paste("Skipping:", T_col, "or", P_col, "not found"))  # Debugging info
    }
}

# Combine all transformed data frames
final_plot_data <- bind_rows(plot_data)

# Check if final_plot_data is empty
if (nrow(final_plot_data) == 0) {
    stop("Error: No valid data available for plotting. Check column names in Cases_TvsP.")
}

# Ensure `Comparison` is a factor with the correct order: AD groups first, then AsymAD groups
final_plot_data$Comparison <- factor(final_plot_data$Comparison, levels = unique(final_plot_data$Comparison))

# Ensure AD groups appear first in facets
final_plot_data$Group <- factor(final_plot_data$Group, levels = c("AD", "AsymAD"))

# Generate the scatter plot with facets
ggplot(final_plot_data, aes(x = X, y = Y, size = Difference, color = Biodomain)) +
    geom_point(alpha = 0.5) +
    scale_color_manual(values = custom_colors) +  # Apply custom colors
    geom_text_repel(aes(label = unique_id), size = 5) +  # Add labels
    theme_bw() +
    facet_wrap(~ Comparison, scales = "free", ncol = 4) +  # Order based on `Comparison`
    labs(
        title = "Comparison of Transcriptomic vs Proteomic Ratios (AD and AsymAD)",
        x = "Transcriptome (% of subjects)",
        y = "Proteome (% of subjects)",
        size = "% difference between omics",
        color = "Biodomain"
    ) +
    theme(
        text = element_text(size = 20),
        legend.position = "right",
        axis.text = element_text(size = 20),
        axis.title = element_text(size = 30),
        #strip.text = element_text(face = "bold")
    ) +
    geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray", size = 0.5) # Add x = y line


########################################################################################################################################################################################################



end.rcode-->

<p>Graph-based Clustering using subdomain Specific Z score Distributions Results (AD male)</p>

#<!--begin.rcode fig.width=25, fig.height=15
library(reshape2)
library(dplyr)
library(igraph)
library(tidyr)
library(DT)
library(pheatmap)
library(ggraph)
library(ggplot2)
library(ggrepel)
library(tidygraph)

#########################################################################################################################################################
#########################################################################################################################################################
## AD_male

# Open the subdomain-specifc Z score distribution file
sig_subdomain_AD_male <- read.delim("/Users/poddea/Desktop/ROSMAP_data_100623/TMT_proteomics/Round2/Subdomain_specific_analysis/sig_subdomain_AD_male.txt", header = TRUE, sep = "\t");


# Ensure column names to` match `IDs`
sig_subdomain_AD_male <- sig_subdomain_AD_male %>% rename_with(~ gsub("X", "", .), starts_with("X"))



# Remove the other columns from the Z score distribution file and keep unique_id and Sample_IDs columns only
sig_subdomain_AD_male <- sig_subdomain_AD_male[, !(colnames(sig_subdomain_AD_male) %in% c("UP_Count", "DOWN_Count"))]

dim(sig_subdomain_AD_male)


# Print the table using DT
datatable(sig_subdomain_AD_male, options = list(pageLength = 5, autoWidth = TRUE))

#########################################################################################################################################################

# Create a data frame with only positive values
sig_subdomain_AD_male_pos <- sig_subdomain_AD_male
sig_subdomain_AD_male_pos[sig_subdomain_AD_male_pos <= 0] <- NA  # Replace all non-positive values with NA

#head(sig_subdomain_AD_male_pos)

# tranfer the data matrix into two column interaction data
sig_subdomain_AD_male_pos_edge <- melt(sig_subdomain_AD_male_pos)

dim(sig_subdomain_AD_male_pos_edge)

# Remove the edges where value (Z score) is "NA"
sig_subdomain_AD_male_pos_edge <- filter(sig_subdomain_AD_male_pos_edge, !is.na(value))

dim(sig_subdomain_AD_male_pos_edge)

# Write the data frame to a file
write.table(sig_subdomain_AD_male_pos_edge, file = "sig_subdomain_AD_male_pos_edge.txt", row.names = FALSE, col.names = TRUE, sep = "\t")

#########################################################################################################################################################

# Create a data frame with only negative values
sig_subdomain_AD_male_neg <- sig_subdomain_AD_male

# Replace all non-negative values with NA in the numeric columns only
sig_subdomain_AD_male_neg[, -1] <- lapply(sig_subdomain_AD_male_neg[, -1], function(x) {
  x[x >= 0] <- NA
  return(x)
})

#head(sig_subdomain_AD_male_neg)

# tranfer the data matrix into two column interaction data
sig_subdomain_AD_male_neg_edge <- melt(sig_subdomain_AD_male_neg)

dim(sig_subdomain_AD_male_neg_edge)

# Remove the edges where value (Z score) is "NA"
sig_subdomain_AD_male_neg_edge <- filter(sig_subdomain_AD_male_neg_edge, !is.na(value))

# use the absolute values for the edges
sig_subdomain_AD_male_neg_edge$value <- abs(sig_subdomain_AD_male_neg_edge$value)


dim(sig_subdomain_AD_male_neg_edge)

head(sig_subdomain_AD_male_neg_edge)

# Write the data frame to a file
write.table(sig_subdomain_AD_male_neg_edge, file = "sig_subdomain_AD_male_neg_edge.txt", row.names = FALSE, col.names = TRUE, sep = "\t")

#########################################################################################################################################################
#########################################################################################################################################################
## AD_female

# Open the subdomain-specifc Z score distribution file
sig_subdomain_AD_female <- read.delim("/Users/poddea/Desktop/ROSMAP_data_100623/TMT_proteomics/Round2/Subdomain_specific_analysis/sig_subdomain_AD_female.txt", header = TRUE, sep = "\t");


# Ensure column names to` match `IDs`
sig_subdomain_AD_female <- sig_subdomain_AD_female %>% rename_with(~ gsub("X", "", .), starts_with("X"))



# Remove the other columns from the Z score distribution file and keep unique_id and Sample_IDs columns only
sig_subdomain_AD_female <- sig_subdomain_AD_female[, !(colnames(sig_subdomain_AD_female) %in% c("UP_Count", "DOWN_Count"))]

dim(sig_subdomain_AD_female)


# Print the table using DT
datatable(sig_subdomain_AD_female, options = list(pageLength = 5, autoWidth = TRUE))

#########################################################################################################################################################

# Create a data frame with only positive values
sig_subdomain_AD_female_pos <- sig_subdomain_AD_female
sig_subdomain_AD_female_pos[sig_subdomain_AD_female_pos <= 0] <- NA  # Replace all non-positive values with NA

#head(sig_subdomain_AD_female_pos)

# tranfer the data matrix into two column interaction data
sig_subdomain_AD_female_pos_edge <- melt(sig_subdomain_AD_female_pos)

dim(sig_subdomain_AD_female_pos_edge)

# Remove the edges where value (Z score) is "NA"
sig_subdomain_AD_female_pos_edge <- filter(sig_subdomain_AD_female_pos_edge, !is.na(value))

dim(sig_subdomain_AD_female_pos_edge)

# Write the data frame to a file
write.table(sig_subdomain_AD_female_pos_edge, file = "sig_subdomain_AD_female_pos_edge.txt", row.names = FALSE, col.names = TRUE, sep = "\t")

#########################################################################################################################################################

# Create a data frame with only negative values
sig_subdomain_AD_female_neg <- sig_subdomain_AD_female

# Replace all non-negative values with NA in the numeric columns only
sig_subdomain_AD_female_neg[, -1] <- lapply(sig_subdomain_AD_female_neg[, -1], function(x) {
  x[x >= 0] <- NA
  return(x)
})

#head(sig_subdomain_AD_female_neg)

# tranfer the data matrix into two column interaction data
sig_subdomain_AD_female_neg_edge <- melt(sig_subdomain_AD_female_neg)

dim(sig_subdomain_AD_female_neg_edge)

# Remove the edges where value (Z score) is "NA"
sig_subdomain_AD_female_neg_edge <- filter(sig_subdomain_AD_female_neg_edge, !is.na(value))

# use the absolute values for the edges
sig_subdomain_AD_female_neg_edge$value <- abs(sig_subdomain_AD_female_neg_edge$value)


dim(sig_subdomain_AD_female_neg_edge)

head(sig_subdomain_AD_female_neg_edge)

# Write the data frame to a file
write.table(sig_subdomain_AD_female_neg_edge, file = "sig_subdomain_AD_female_neg_edge.txt", row.names = FALSE, col.names = TRUE, sep = "\t")

#########################################################################################################################################################
#########################################################################################################################################################
## AsymAD_male

# Open the subdomain-specifc Z score distribution file
sig_subdomain_AsymAD_male <- read.delim("/Users/poddea/Desktop/ROSMAP_data_100623/TMT_proteomics/Round2/Subdomain_specific_analysis/sig_subdomain_AsymAD_male.txt", header = TRUE, sep = "\t");


# Ensure column names to` match `IDs`
sig_subdomain_AsymAD_male <- sig_subdomain_AsymAD_male %>% rename_with(~ gsub("X", "", .), starts_with("X"))



# Remove the other columns from the Z score distribution file and keep unique_id and Sample_IDs columns only
sig_subdomain_AsymAD_male <- sig_subdomain_AsymAD_male[, !(colnames(sig_subdomain_AsymAD_male) %in% c("UP_Count", "DOWN_Count"))]

dim(sig_subdomain_AsymAD_male)


# Print the table using DT
datatable(sig_subdomain_AsymAD_male, options = list(pageLength = 5, autoWidth = TRUE))

#########################################################################################################################################################

# Create a data frame with only positive values
sig_subdomain_AsymAD_male_pos <- sig_subdomain_AsymAD_male
sig_subdomain_AsymAD_male_pos[sig_subdomain_AsymAD_male_pos <= 0] <- NA  # Replace all non-positive values with NA

#head(sig_subdomain_AsymAD_male_pos)

# tranfer the data matrix into two column interaction data
sig_subdomain_AsymAD_male_pos_edge <- melt(sig_subdomain_AsymAD_male_pos)

dim(sig_subdomain_AsymAD_male_pos_edge)

# Remove the edges where value (Z score) is "NA"
sig_subdomain_AsymAD_male_pos_edge <- filter(sig_subdomain_AsymAD_male_pos_edge, !is.na(value))

dim(sig_subdomain_AsymAD_male_pos_edge)

# Write the data frame to a file
write.table(sig_subdomain_AsymAD_male_pos_edge, file = "sig_subdomain_AsymAD_male_pos_edge.txt", row.names = FALSE, col.names = TRUE, sep = "\t")

#########################################################################################################################################################

# Create a data frame with only negative values
sig_subdomain_AsymAD_male_neg <- sig_subdomain_AsymAD_male

# Replace all non-negative values with NA in the numeric columns only
sig_subdomain_AsymAD_male_neg[, -1] <- lapply(sig_subdomain_AsymAD_male_neg[, -1], function(x) {
  x[x >= 0] <- NA
  return(x)
})

#head(sig_subdomain_AsymAD_male_neg)

# tranfer the data matrix into two column interaction data
sig_subdomain_AsymAD_male_neg_edge <- melt(sig_subdomain_AsymAD_male_neg)

dim(sig_subdomain_AsymAD_male_neg_edge)

# Remove the edges where value (Z score) is "NA"
sig_subdomain_AsymAD_male_neg_edge <- filter(sig_subdomain_AsymAD_male_neg_edge, !is.na(value))

# use the absolute values for the edges
sig_subdomain_AsymAD_male_neg_edge$value <- abs(sig_subdomain_AsymAD_male_neg_edge$value)


dim(sig_subdomain_AsymAD_male_neg_edge)

head(sig_subdomain_AsymAD_male_neg_edge)

# Write the data frame to a file
write.table(sig_subdomain_AsymAD_male_neg_edge, file = "sig_subdomain_AsymAD_male_neg_edge.txt", row.names = FALSE, col.names = TRUE, sep = "\t")

#########################################################################################################################################################
#########################################################################################################################################################
#########################################################################################################################################################
#########################################################################################################################################################
## AsymAD_female

# Open the subdomain-specifc Z score distribution file
sig_subdomain_AsymAD_female <- read.delim("/Users/poddea/Desktop/ROSMAP_data_100623/TMT_proteomics/Round2/Subdomain_specific_analysis/sig_subdomain_AsymAD_female.txt", header = TRUE, sep = "\t");


# Ensure column names to` match `IDs`
sig_subdomain_AsymAD_female <- sig_subdomain_AsymAD_female %>% rename_with(~ gsub("X", "", .), starts_with("X"))



# Remove the other columns from the Z score distribution file and keep unique_id and Sample_IDs columns only
sig_subdomain_AsymAD_female <- sig_subdomain_AsymAD_female[, !(colnames(sig_subdomain_AsymAD_female) %in% c("UP_Count", "DOWN_Count"))]

dim(sig_subdomain_AsymAD_female)


# Print the table using DT
datatable(sig_subdomain_AsymAD_female, options = list(pageLength = 5, autoWidth = TRUE))

#########################################################################################################################################################

# Create a data frame with only positive values
sig_subdomain_AsymAD_female_pos <- sig_subdomain_AsymAD_female
sig_subdomain_AsymAD_female_pos[sig_subdomain_AsymAD_female_pos <= 0] <- NA  # Replace all non-positive values with NA

#head(sig_subdomain_AsymAD_female_pos)

# tranfer the data matrix into two column interaction data
sig_subdomain_AsymAD_female_pos_edge <- melt(sig_subdomain_AsymAD_female_pos)

dim(sig_subdomain_AsymAD_female_pos_edge)

# Remove the edges where value (Z score) is "NA"
sig_subdomain_AsymAD_female_pos_edge <- filter(sig_subdomain_AsymAD_female_pos_edge, !is.na(value))

dim(sig_subdomain_AsymAD_female_pos_edge)

# Write the data frame to a file
write.table(sig_subdomain_AsymAD_female_pos_edge, file = "sig_subdomain_AsymAD_female_pos_edge.txt", row.names = FALSE, col.names = TRUE, sep = "\t")

#########################################################################################################################################################

# Create a data frame with only negative values
sig_subdomain_AsymAD_female_neg <- sig_subdomain_AsymAD_female

# Replace all non-negative values with NA in the numeric columns only
sig_subdomain_AsymAD_female_neg[, -1] <- lapply(sig_subdomain_AsymAD_female_neg[, -1], function(x) {
  x[x >= 0] <- NA
  return(x)
})

#head(sig_subdomain_AsymAD_female_neg)

# tranfer the data matrix into two column interaction data
sig_subdomain_AsymAD_female_neg_edge <- melt(sig_subdomain_AsymAD_female_neg)

dim(sig_subdomain_AsymAD_female_neg_edge)

# Remove the edges where value (Z score) is "NA"
sig_subdomain_AsymAD_female_neg_edge <- filter(sig_subdomain_AsymAD_female_neg_edge, !is.na(value))

# use the absolute values for the edges
sig_subdomain_AsymAD_female_neg_edge$value <- abs(sig_subdomain_AsymAD_female_neg_edge$value)


dim(sig_subdomain_AsymAD_female_neg_edge)

head(sig_subdomain_AsymAD_female_neg_edge)

# Write the data frame to a file
write.table(sig_subdomain_AsymAD_female_neg_edge, file = "sig_subdomain_AsymAD_female_neg_edge.txt", row.names = FALSE, col.names = TRUE, sep = "\t")

end.rcode-->






# create igraph S3 object
net_pos_AD_male <- graph.data.frame(sig_subdomain_AD_male_pos_edge, directed = FALSE)

# Get unique vertices from biodomain_subdomain_annotation and variable
term_name_vertices <- unique(sig_subdomain_AD_male_pos_edge$biodomain_subdomain_annotation)
variable_vertices <- unique(sig_subdomain_AD_male_pos_edge$variable)

# Assign shape "square" to term_name vertices and "circle" to variable vertices
vertex_shapes <- rep("circle", vcount(net_pos_AD_male))  # Initialize all vertices as circles
vertex_shapes[V(net_pos_AD_male)$name %in% term_name_vertices] <- "square"  # Assign square shape to Var1 vertices

# store original margins
orig_mar <- par()$mar

# set new margins to limit whitespace in plot
par(mar=rep(.1, 4))

# plot the igraph S3 object
# We can use various layout algorithms in igraph to generate the layout, such as Fruchterman-Reingold layout (layout_with_fr), Kamada-Kawai layout (layout_with_kk), or circular layout (layout_in_circle)
plot(net_pos_AD_male,  layout = layout_with_fr(net_pos_AD_male), edge.width = E(net_pos_AD_male)$value, vertex.label.cex = .5, vertex.size = 3, vertex.shape = vertex_shapes)

# Export your igraph object as an edge list
write.graph(net_pos_AD_male, file = "net_pos_AD_male.graphml", format = "graphml")



# community detection based on edge betweenness (Newman-Girvan)
#ceb_pos_AD_male <- cluster_edge_betweenness(net_pos_AD_male, weights = E(net_pos_AD_male)$value)

# community detection based on Infomap Algorithm
#ceb_pos_AD_male <- cluster_infomap(net_pos_AD_male, e.weights = E(net_pos_AD_male)$value)

# community detection based on Louvain Clustering (Modularity Optimization)
ceb_pos_AD_male <- cluster_louvain(net_pos_AD_male, weights = E(net_pos_AD_male)$value)

class(ceb_pos_AD_male)

# plot the igraph S3 objec twith sub-cluster
plot(ceb_pos_AD_male, net_pos_AD_male, layout = layout_with_fr(net_pos_AD_male), edge.width = E(net_pos_AD_male)$value, vertex.label.cex = .5, vertex.size = 3, vertex.shape = vertex_shapes)


# community membership for each node
par(mar=orig_mar)

dendPlot(ceb_pos_AD_male, mode="hclust", cex=.5)

# Get the community membership data
community_membership_pos_AD_male <- membership(ceb_pos_AD_male)

# Convert it to a data frame with two columns: Node and Community
community_df_pos_AD_male <- data.frame(Node = names(community_membership_pos_AD_male), Community = as.integer(community_membership_pos_AD_male))

# Count the number of community detected
unique(community_df_pos_AD_male$Community)

# Write the data frame to a file
write.table(community_df_pos_AD_male, file = "community_membership_subdomain_pos_AD_male.txt", row.names = FALSE, col.names = TRUE, sep = "\t")

##################################################################################################################################################
# Make individual community as example

# Subset the graph for Community 5
community_5_nodes <- V(net_pos_AD_male)[community_df_pos_AD_male$Community == 5]  # Select nodes from Community 5

# Induce a subgraph with only Community 5 nodes
subgraph_community_5 <- induced_subgraph(net_pos_AD_male, community_5_nodes)

# Assign "circle" shape to all vertices
V(subgraph_community_5)$shape <- "circle"

# Set "square" shape for vertices that match the term_name_vertices
V(subgraph_community_5)$shape[V(subgraph_community_5)$name %in% term_name_vertices] <- "square"

# Assign "blue" color to all vertices (default for circles)
V(subgraph_community_5)$color <- "lightblue"

# Set "red" color for vertices that are squares
V(subgraph_community_5)$color[V(subgraph_community_5)$shape == "square"] <- "khaki1"

# set new margins to limit whitespace in plot
#par(mar=rep(.1, 4))

# Plot the subgraph for Community 5
plot(subgraph_community_5, layout = layout_with_fr(subgraph_community_5), edge.width = E(net_pos_AD_male)$value, vertex.size = 10, vertex.label.cex = 1, vertex.label.color = "black", main = "Community 5 Subgraph")

# Convert igraph object to tbl_graph (a tidygraph object)
#graph_tbl <- as_tbl_graph(subgraph_community_5)

# Create the ggraph plot
#ggraph(graph_tbl, layout = 'fr') +  # Fruchterman-Reingold layout
  #geom_edge_link(aes(width = E(subgraph_community_5)$value), alpha = 0.5) +  # Edges
  #geom_node_point(aes(color = V(subgraph_community_5)$color, shape = V(subgraph_community_5)$shape), size = 10) +  # Vertices
  #geom_node_text(aes(label = V(subgraph_community_5)$name), repel = TRUE, size = 10) +  # Non-overlapping labels
  #theme_void() +  # Minimalist theme
  #scale_shape_manual(values = c("circle" = 16, "square" = 15)) +  # Map shapes
  #scale_color_manual(values = c("lightblue", "khaki1"))  # Map colors


##################################################################################################################################################
# Make heatmap for the comunitties

# Select the biodomain_subdomain_annotation and variable entities from the sig_subdomain_AD_male_pos_edge file
term_name <- sig_subdomain_AD_male_pos_edge$biodomain_subdomain_annotation
variable <- sig_subdomain_AD_male_pos_edge$variable

# Separate term_name and variable entities based on their community membership and sort the Community column in ascending order
term_name_nodes <- community_df_pos_AD_male[community_df_pos_AD_male$Node %in% term_name, ]
term_name_nodes <- term_name_nodes[order(term_name_nodes$Community), ]


variable_nodes <- community_df_pos_AD_male[community_df_pos_AD_male$Node %in% variable, ]
variable_nodes <- variable_nodes[order(variable_nodes$Community), ]


head(term_name_nodes)

head(variable_nodes)

# Prepare the row and col entries for a heatmap based on term_name and variable entities
row_names <- unique(c(term_name_nodes$Node))

col_names <- unique(c(variable_nodes$Node))

# Create a matrix filled with zeros
matrix_data_AD_male_pos <- matrix(0, nrow = length(row_names), ncol = length(col_names), dimnames = list(row_names, col_names))

# Populate the matrix based on the information in term_name_nodes and variable_nodes
for (i in 1:nrow(term_name_nodes)) {
          matrix_data_AD_male_pos[term_name_nodes[i, "Node"], variable_nodes[variable_nodes$Community == term_name_nodes[i, "Community"], "Node"]] <- variable_nodes[variable_nodes$Community == term_name_nodes[i, "Community"], "Community"]
}


write.table(matrix_data_AD_male_pos,"subdomain_matrix_data_pos_AD_male.txt",sep="\t",quote=F)

# Create heatmap with matrix
matrix_data_AD_male_pos <- as.matrix(matrix_data_AD_male_pos)

# Adjust the margins to make room for the X-axis labels
par(mar = c(5, 5, 4, 2) + 0.1)

heatmap(matrix_data_AD_male_pos, Rowv = NA, Colv = NA, cex.axis = 0.5, main = "Communities identified by Graph Based Clustering for subdomain Comparative subdomain Enrichment Analysis (Male UP subdomains)")


#########################################################################################################################################################

# tranfer the data matrix into two column interaction data
sig_subdomain_AD_male_neg_edge <- melt(sig_subdomain_AD_male_neg)

dim(sig_subdomain_AD_male_neg_edge)

# Remove the edges where value (Z score) is "NA"
sig_subdomain_AD_male_neg_edge <- filter(sig_subdomain_AD_male_neg_edge, !is.na(value))

dim(sig_subdomain_AD_male_neg_edge)

# Convert the negative values in the 'value' column to absolute value for network construction
sig_subdomain_AD_male_neg_edge$value <- abs(sig_subdomain_AD_male_neg_edge$value)

# create igraph S3 object
net_neg_AD_male <- graph.data.frame(sig_subdomain_AD_male_neg_edge, directed = FALSE)

# Get unique vertices from biodomain_subdomain_annotation and variable
term_name_vertices <- unique(sig_subdomain_AD_male_neg_edge$biodomain_subdomain_annotation)
variable_vertices <- unique(sig_subdomain_AD_male_neg_edge$variable)

# Assign shape "square" to term_name vertices and "circle" to variable vertices
vertex_shapes <- rep("circle", vcount(net_neg_AD_male))  # Initialize all vertices as circles
vertex_shapes[V(net_neg_AD_male)$name %in% term_name_vertices] <- "square"  # Assign square shape to Var1 vertices

# store original margins
orig_mar <- par()$mar

# set new margins to limit whitespace in plot
par(mar=rep(.1, 4))

# plot the igraph S3 object
# We can use various layout algorithms in igraph to generate the layout, such as Fruchterman-Reingold layout (layout_with_fr), Kamada-Kawai layout (layout_with_kk), or circular layout (layout_in_circle)
plot(net_neg_AD_male,  layout = layout_with_fr(net_neg_AD_male), edge.width = E(net_neg_AD_male)$value, vertex.label.cex = .5, vertex.size = 3, vertex.shape = vertex_shapes)

# community detection based on Weighted Newman-Girvan (Edge Betweenness)
#ceb_neg_AD_male <- cluster_edge_betweenness(net_neg_AD_male, weights = E(net_neg_AD_male)$value)

# community detection based on Louvain Clustering (Modularity Optimization)
ceb_neg_AD_male <- cluster_louvain(net_neg_AD_male, weights = E(net_neg_AD_male)$value)

# community detection based on Infomap Algorithm
#ceb_neg_AD_male <- cluster_infomap(net_neg_AD_male, e.weights = E(net_neg_AD_male)$value)

# community detection based on Walktrap Algorithm
#ceb_neg_AD_male <- cluster_walktrap(net_neg_AD_male, weights = E(net_neg_AD_male)$value)


class(ceb_neg_AD_male)


# plot the igraph S3 objec twith sub-cluster
plot(ceb_neg_AD_male, net_neg_AD_male, layout = layout_with_fr(net_neg_AD_male), edge.width = E(net_neg_AD_male)$value, vertex.label.cex = .5, vertex.size = 3, vertex.shape = vertex_shapes)

# community membership for each node
par(mar=orig_mar)

dendPlot(ceb_neg_AD_male, mode="hclust", cex=.5)

# Get the community membership data
community_membership_neg_AD_male <- membership(ceb_neg_AD_male)

# Convert it to a data frame with two columns: Node and Community
community_df_neg_AD_male <- data.frame(Node = names(community_membership_neg_AD_male), Community = as.integer(community_membership_neg_AD_male))

# Count the number of community detected
unique(community_df_neg_AD_male$Community)

# Write the data frame to a file
write.table(community_df_neg_AD_male, file = "community_membership_subdomain_neg_AD_male.txt", row.names = FALSE, col.names = TRUE, sep = "\t")

# Select the biodomain_subdomain_annotation and variable entities from the sig_subdomain_AD_male_neg_edge file
term_name <- sig_subdomain_AD_male_neg_edge$biodomain_subdomain_annotation
variable <- sig_subdomain_AD_male_neg_edge$variable

# Separate term_name and variable entities based on their community membership and sort the Community column in ascending order
term_name_nodes <- community_df_neg_AD_male[community_df_neg_AD_male$Node %in% term_name, ]
term_name_nodes <- term_name_nodes[order(term_name_nodes$Community), ]


variable_nodes <- community_df_neg_AD_male[community_df_neg_AD_male$Node %in% variable, ]
variable_nodes <- variable_nodes[order(variable_nodes$Community), ]


head(term_name_nodes)

head(variable_nodes)

# Prepare the row and col entries for a heatmap based on term_name and variable entities
row_names <- unique(c(term_name_nodes$Node))

col_names <- unique(c(variable_nodes$Node))

# Create a matrix filled with zeros
matrix_data_AD_male_neg <- matrix(0, nrow = length(row_names), ncol = length(col_names), dimnames = list(row_names, col_names))

# Populate the matrix based on the information in term_name_nodes and variable_nodes
for (i in 1:nrow(term_name_nodes)) {
          matrix_data_AD_male_neg[term_name_nodes[i, "Node"], variable_nodes[variable_nodes$Community == term_name_nodes[i, "Community"], "Node"]] <- variable_nodes[variable_nodes$Community == term_name_nodes[i, "Community"], "Community"]
}


write.table(matrix_data_AD_male_neg,"subdomain_matrix_data_neg_AD_male.txt",sep="\t",quote=F)

# Create heatmap with matrix
matrix_data_AD_male_neg <- as.matrix(matrix_data_AD_male_neg)

# Adjust the margins to make room for the X-axis labels
par(mar = c(5, 5, 4, 2) + 0.1)

heatmap(matrix_data_AD_male_neg, Rowv = NA, Colv = NA, cex.axis = 0.5, main = "Communities identified by Graph Based Clustering for subdomain Comparative subdomain Enrichment Analysis (Male DOWN subdomains)")



end.rcode-->

#<p>Graph-based Clustering using subdomain Specific Z score Distributions Results (AD female)</p>

#<!--begin.rcode fig.width=25, fig.height=15
library(reshape2)
library(dplyr)
library(igraph)
library(tidyr)
library(DT)

## AD_male

# Open the subdomain-specifc Z score distribution file
sig_subdomain_AD_female <- read.delim("/Users/poddea/Desktop/ROSMAP_data_100623/RNASeq_Harmonization_Study/Biodomain_mapping/Subdomain/subdomain_specific_analysis/sig_subdomain_AD_female.txt", header = TRUE, sep = "\t");

# Ensure column names to` match `IDs`
sig_subdomain_AD_female <- sig_subdomain_AD_female %>% rename_with(~ gsub("X", "", .), starts_with("X"))


# Copy the Biodomain_subdomain annotation from data_subdomain
biodomain_subdomain_annotation <- data_subdomain$Biodomain_Subdomain

#head(biodomain_subdomain_name)

# Merge the biodomain_subdomain annotation file to the Z score distribution file to get biodomain_subdomain_name column
sig_subdomain_AD_female<- cbind(biodomain_subdomain_annotation, sig_subdomain_AD_female)

# Remove the other columns from the Z score distribution file and keep unique_id and Sample_IDs columns only
sig_subdomain_AD_female <- sig_subdomain_AD_female[, !(colnames(sig_subdomain_AD_female) %in% c("unique_id", "UP_Count", "DOWN_Count"))]


dim(sig_subdomain_AD_female)

# Print the table using DT
datatable(sig_subdomain_AD_female, options = list(pageLength = 5, autoWidth = TRUE))

# Create a data frame with only positive values
sig_subdomain_AD_female_pos <- sig_subdomain_AD_female
sig_subdomain_AD_female_pos[sig_subdomain_AD_female_pos <= 0] <- NA  # Replace all non-positive values with NA

#head(sig_subdomain_AD_female_pos)

# Create a data frame with only negative values
sig_subdomain_AD_female_neg <- sig_subdomain_AD_female

# Replace all non-negative values with NA in the numeric columns only
sig_subdomain_AD_female_neg[, -1] <- lapply(sig_subdomain_AD_female_neg[, -1], function(x) {
  x[x >= 0] <- NA
  return(x)
})

#head(sig_subdomain_AD_female_neg)

#########################################################################################################################################################

# tranfer the data matrix into two column interaction data
sig_subdomain_AD_female_pos_edge <- melt(sig_subdomain_AD_female_pos)

dim(sig_subdomain_AD_female_pos_edge)

# select the edges where value (Z score) is "NA"
sig_subdomain_AD_female_pos_edge <- filter(sig_subdomain_AD_female_pos_edge, !is.na(value))

dim(sig_subdomain_AD_female_pos_edge)

write.table(sig_subdomain_AD_female_pos_edge, file = "sig_subdomain_AD_female_pos_edge.txt", row.names = FALSE, col.names = TRUE, sep = "\t")

# create igraph S3 object
net_pos_AD_female <- graph.data.frame(sig_subdomain_AD_female_pos_edge, directed = FALSE)

# Get unique vertices from biodomain_subdomain_annotation and variable
term_name_vertices <- unique(sig_subdomain_AD_female_pos_edge$biodomain_subdomain_annotation)
variable_vertices <- unique(sig_subdomain_AD_female_pos_edge$variable)

# Assign shape "square" to term_name vertices and "circle" to variable vertices
vertex_shapes <- rep("circle", vcount(net_pos_AD_female))  # Initialize all vertices as circles
vertex_shapes[V(net_pos_AD_female)$name %in% term_name_vertices] <- "square"  # Assign square shape to Var1 vertices

# store original margins
orig_mar <- par()$mar

# set new margins to limit whitespace in plot
par(mar=rep(.1, 4))

# plot the igraph S3 object
# We can use various layout algorithms in igraph to generate the layout, such as Fruchterman-Reingold layout (layout_with_fr), Kamada-Kawai layout (layout_with_kk), or circular layout (layout_in_circle)
plot(net_pos_AD_female,  layout = layout_with_fr(net_pos_AD_female), edge.width = E(net_pos_AD_female)$value, vertex.label.cex = .5, vertex.size = 3, vertex.shape = vertex_shapes)

# community detection based on edge betweenness (Newman-Girvan)
#ceb_pos_AD_female <- cluster_edge_betweenness(net_pos_AD_female)

# community detection based on Infomap Algorithm
#ceb_pos_AD_female <- cluster_infomap(net_pos_AD_female, e.weights = E(net_pos_AD_female)$value)

# community detection based on Louvain Clustering (Modularity Optimization)
ceb_pos_AD_female <- cluster_louvain(net_pos_AD_female, weights = E(net_pos_AD_female)$value)

class(ceb_pos_AD_female)

# plot the igraph S3 objec twith sub-cluster
plot(ceb_pos_AD_female, net_pos_AD_female, layout = layout_with_fr(net_pos_AD_female), edge.width = E(net_pos_AD_female)$value, vertex.label.cex = .5, vertex.size = 3, vertex.shape = vertex_shapes)

# community membership for each node
par(mar=orig_mar)

dendPlot(ceb_pos_AD_female, mode="hclust", cex=.5)

# Get the community membership data
community_membership_pos_AD_female <- membership(ceb_pos_AD_female)

# Convert it to a data frame with two columns: Node and Community
community_df_pos_AD_female <- data.frame(Node = names(community_membership_pos_AD_female), Community = as.integer(community_membership_pos_AD_female))

# Count the number of community detected
unique(community_df_pos_AD_female$Community)

# Write the data frame to a file
write.table(community_df_pos_AD_female, file = "community_membership_subdomain_pos_AD_female.txt", row.names = FALSE, col.names = TRUE, sep = "\t")

# Select the biodomain_subdomain_annotation and variable entities from the sig_subdomain_AD_female_pos_edge file
term_name <- sig_subdomain_AD_female_pos_edge$biodomain_subdomain_annotation
variable <- sig_subdomain_AD_female_pos_edge$variable

# Separate term_name and variable entities based on their community membership and sort the Community column in ascending order
term_name_nodes <- community_df_pos_AD_female[community_df_pos_AD_female$Node %in% term_name, ]
term_name_nodes <- term_name_nodes[order(term_name_nodes$Community), ]


variable_nodes <- community_df_pos_AD_female[community_df_pos_AD_female$Node %in% variable, ]
variable_nodes <- variable_nodes[order(variable_nodes$Community), ]


head(term_name_nodes)

head(variable_nodes)

# Prepare the row and col entries for a heatmap based on term_name and variable entities
row_names <- unique(c(term_name_nodes$Node))

col_names <- unique(c(variable_nodes$Node))

# Create a matrix filled with zeros
matrix_data_AD_female_pos <- matrix(0, nrow = length(row_names), ncol = length(col_names), dimnames = list(row_names, col_names))

# Populate the matrix based on the information in term_name_nodes and variable_nodes
for (i in 1:nrow(term_name_nodes)) {
          matrix_data_AD_female_pos[term_name_nodes[i, "Node"], variable_nodes[variable_nodes$Community == term_name_nodes[i, "Community"], "Node"]] <- variable_nodes[variable_nodes$Community == term_name_nodes[i, "Community"], "Community"]
}


write.table(matrix_data_AD_female_pos,"subdomain_matrix_data_pos_AD_female.txt",sep="\t",quote=F)

# Create heatmap with matrix
matrix_data_AD_female_pos <- as.matrix(matrix_data_AD_female_pos)

# Adjust the margins to make room for the X-axis labels
par(mar = c(5, 5, 4, 2) + 0.1)

heatmap(matrix_data_AD_female_pos, Rowv = NA, Colv = NA, cex.axis = 0.5, main = "Communities identified by Graph Based Clustering for subdomain Comparative subdomain Enrichment Analysis (Female UP subdomains)")



#########################################################################################################################################################

# tranfer the data matrix into two column interaction data
sig_subdomain_AD_female_neg_edge <- melt(sig_subdomain_AD_female_neg)

dim(sig_subdomain_AD_female_neg_edge)

# select the edges where value (Z score) is "NA"
sig_subdomain_AD_female_neg_edge <- filter(sig_subdomain_AD_female_neg_edge, !is.na(value))

dim(sig_subdomain_AD_female_neg_edge)

# Convert the negative values in the 'value' column to absolute value for network construction
sig_subdomain_AD_female_neg_edge$value <- abs(sig_subdomain_AD_female_neg_edge$value)

# create igraph S3 object
net_neg_AD_female <- graph.data.frame(sig_subdomain_AD_female_neg_edge, directed = FALSE)

# Get unique vertices from biodomain_subdomain_annotation and variable
term_name_vertices <- unique(sig_subdomain_AD_female_neg_edge$biodomain_subdomain_annotation)
variable_vertices <- unique(sig_subdomain_AD_female_neg_edge$variable)

# Assign shape "square" to term_name vertices and "circle" to variable vertices
vertex_shapes <- rep("circle", vcount(net_neg_AD_female))  # Initialize all vertices as circles
vertex_shapes[V(net_neg_AD_female)$name %in% term_name_vertices] <- "square"  # Assign square shape to Var1 vertices

# store original margins
orig_mar <- par()$mar

# set new margins to limit whitespace in plot
par(mar=rep(.1, 4))

# plot the igraph S3 object
# We can use various layout algorithms in igraph to generate the layout, such as Fruchterman-Reingold layout (layout_with_fr), Kamada-Kawai layout (layout_with_kk), or circular layout (layout_in_circle)
plot(net_neg_AD_female,  layout = layout_with_fr(net_neg_AD_female), edge.width = E(net_neg_AD_female)$value, vertex.label.cex = .5, vertex.size = 3, vertex.shape = vertex_shapes)

# community detection based on edge betweenness (Newman-Girvan)
#ceb_neg_AD_female <- cluster_edge_betweenness(net_neg_AD_female)

# community detection based on Infomap Algorithm
#ceb_neg_AD_female <- cluster_infomap(net_neg_AD_female, e.weights = E(net_neg_AD_female)$value)

# community detection based on Louvain Clustering (Modularity Optimization)
ceb_neg_AD_female <- cluster_louvain(net_neg_AD_female, weights = E(net_neg_AD_female)$value)

class(ceb_neg_AD_female)

# plot the igraph S3 objec twith sub-cluster
plot(ceb_neg_AD_female, net_neg_AD_female, layout = layout_with_fr(net_neg_AD_female), edge.width = E(net_neg_AD_female)$value, vertex.label.cex = .5, vertex.size = 3, vertex.shape = vertex_shapes)

# community membership for each node
par(mar=orig_mar)

dendPlot(ceb_neg_AD_female, mode="hclust", cex=.5)

# Get the community membership data
community_membership_neg_AD_female <- membership(ceb_neg_AD_female)

# Convert it to a data frame with two columns: Node and Community
community_df_neg_AD_female <- data.frame(Node = names(community_membership_neg_AD_female), Community = as.integer(community_membership_neg_AD_female))

# Count the number of community detected
unique(community_df_neg_AD_female$Community)

# Write the data frame to a file
write.table(community_df_neg_AD_female, file = "community_membership_subdomain_neg_AD_female.txt", row.names = FALSE, col.names = TRUE, sep = "\t")

# Select the biodomain_subdomain_annotation and variable entities from the sig_subdomain_AD_female_neg_edge file
term_name <- sig_subdomain_AD_female_neg_edge$biodomain_subdomain_annotation
variable <- sig_subdomain_AD_female_neg_edge$variable

# Separate term_name and variable entities based on their community membership and sort the Community column in ascending order
term_name_nodes <- community_df_neg_AD_female[community_df_neg_AD_female$Node %in% term_name, ]
term_name_nodes <- term_name_nodes[order(term_name_nodes$Community), ]


variable_nodes <- community_df_neg_AD_female[community_df_neg_AD_female$Node %in% variable, ]
variable_nodes <- variable_nodes[order(variable_nodes$Community), ]


head(term_name_nodes)

head(variable_nodes)

# Prepare the row and col entries for a heatmap based on term_name and variable entities
row_names <- unique(c(term_name_nodes$Node))

col_names <- unique(c(variable_nodes$Node))

# Create a matrix filled with zeros
matrix_data_AD_female_neg <- matrix(0, nrow = length(row_names), ncol = length(col_names), dimnames = list(row_names, col_names))

# Populate the matrix based on the information in term_name_nodes and variable_nodes
for (i in 1:nrow(term_name_nodes)) {
          matrix_data_AD_female_neg[term_name_nodes[i, "Node"], variable_nodes[variable_nodes$Community == term_name_nodes[i, "Community"], "Node"]] <- variable_nodes[variable_nodes$Community == term_name_nodes[i, "Community"], "Community"]
}


write.table(matrix_data_AD_female_neg,"subdomain_matrix_data_neg_AD_female.txt",sep="\t",quote=F)

# Create heatmap with matrix
matrix_data_AD_female_neg <- as.matrix(matrix_data_AD_female_neg)

# Adjust the margins to make room for the X-axis labels
par(mar = c(5, 5, 4, 2) + 0.1)

heatmap(matrix_data_AD_female_neg, Rowv = NA, Colv = NA, cex.axis = 0.5, main = "Communities identified by Graph Based Clustering for subdomain Comparative subdomain Enrichment Analysis (Female DOWN subdomains)")


#tiff("matrix_data.tiff", width = 20, height = 15, units = "in", res = 300)  # Increase width, height, and resolution
end.rcode-->

<p>Save individual matrix file as .tiff format</p>

#<!--begin.rcode fig.width=25, fig.height=15

# List of matrix data
matrix_list <- list(matrix_data_AD_male_pos, matrix_data_AD_male_neg, matrix_data_AD_female_pos, matrix_data_AD_female_neg)

# Corresponding file names for each heatmap
file_names <- c("matrix_data_AD_male_pos.tiff", "matrix_data_AD_male_neg.tiff", "matrix_data_AD_female_pos.tiff", "matrix_data_AD_female_neg.tiff")

# Loop through each matrix and save heatmap as a TIFF file
for (i in 1:length(matrix_list)) {
  # Open TIFF device with specific resolution and size
  tiff(file = file_names[i], width = 20, height = 10, units = "in", res = 300)
  
  # Plot the heatmap (you can customize the heatmap function as needed)
  heatmap(matrix_list[[i]], Rowv = NA, Colv = NA, cexRow = 0.5, cexCol = 0.5, main = paste("Heatmap", i))
  
  # Close the device to save the file
  dev.off()
}

end.rcode-->



</body>
</html>
